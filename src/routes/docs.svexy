---
layout: ./_DocsLayout.svelte
nav:
  - [Install, docs#install-it]
  - [Use, docs#use-it]
  - [
      Options,
      docs#options,
      [
        [extension, docs#extension, true],
        [smartypants, docs#smartypants, true],
        [layout, docs#layout, true],
        [components, docs#components, true],
        [remarkPlugins, docs#remarkPlugins, true],
        [rehypePlugins, docs#rehypePlugins, true],
      ],
    ]
  - [
      Frontmatter,
      docs#frontmatter,
      [
        [variables, docs#variables, false],
        [layouts, docs#layout-1, false],
        [components, docs#components-1, false],
      ],
    ]
  - [Integrations, docs#integrations]
---

# mdsvex

```svelte
<script>
  export let count = 0;

  function some_func(args) {
    return args * 2;
  }
</script>

<style>
  button {
    border-radius: 2px;
    background: pink;
  }
</style>

<button on:click={({ hello }) => count++ }>Hello</button>

{#each Array(10).map(x => x * 2) as { a, b, c }, index (key) }
    <Component prop={[1, 2, 3]}  {...function_call(args) } />
{/each}

{@debug value}
```

A markdown preprocessor for [Svelte][svelte] components. Basically [MDX][mdx] for Svelte.

This preprocessor allows you use Svelte components in your markdown, or markdown in your Svelte components.

mdsvex supports all Svelte syntax and _almost_ all markdown syntax. See [limitations](docs/#limitations) for more information.

You can do this:

```mdsvex
<script>
	import { Chart } from "../components/Chart.svelte";
</script>

# Here’s a chart

The chart is rendered inside our MDsveX document.

<Chart />
```

It uses [unified], [remark] and [rehype] and you can use any [remark plugins][remark_plugins] or [rehype plugins][rehype_plugins] to enhance your experience.

[Try it](/playground)

## Install it

Install it as a dev-dependency.

With `npm`:

```bash
npm i --save-dev mdsvex
```

With `yarn`:

```bash
yarn add --dev mdsvex
```

## Use it

The `mdsvex` preprocessor function is a named import from the `mdsvex` module. Add it as a preprocessor to you rollup or webpack config, and tell the Svelte plugin or loader to also handle `.svexy` files:

```js
import { mdsvex } from "mdsvex";

export default {
	...boring_config_stuff,
	plugins: [
		svelte({
			// tell svelte to handle mdsvex files
			extensions: [".svelte", ".svexy"],
			preprocess: mdsvex()
		})
	]
};
```

> If you don't like the `.svexy` file extension, fear not, it is easily customised.

## Options

The preprocessor function accepts an object of options, that allow you customise your experience. The options are global to all parsed files.

```ts
interface MdsvexOptions {
	extension: string;
	smartypants: boolean | smartypantsOptions;
	layout: string | Array<RegExp, string>;
	components:
		| { [element: string]: string }
		| Array<RegExp, { [element: string]: string }>;
	remarkPlugins: Array<plugin> | Array<[plugin, plugin_options]>;
	rehypePlugins: Array<plugin> | Array<[plugin, plugin_options]>;
}
```

`mdsvex` also allows you to define certain options in [YAML frontmatter](docs#frontmatter), to modify behaviour on a _per-file_ basis.

### `extension`

```ts
extension: string = ".svexy";
```

The `extension` option allows you to set a custom file extension for files written in mdsvex, the default value is `.svexy`. Whatever value you choose here must be passed to the `extensions` field of `rollup-plugin-svelte` or `svelte-loader`. If you to not change the default, you must still pass the extension name to the plugin or loader config.

```js
export default {
	...config,
	plugins: [
		svelte({
			extensions: [".svelte", ".custom"],
			preprocess: mdsvex({
				extension: ".custom"
			})
		})
	]
};
```

### `smartypants`

```ts
smartypants: boolean | {
  quotes: boolean = true;
  ellipses: boolean = true;
  backticks: boolean | 'all' = true;
  dashes: boolean | 'oldschool' | 'inverted' = true;
} = true;
```

The `smartypants` transforms plain ASCII punctuation into fancy typographic punctuation HTML entities.

It turns stuff like:

```md
"They said it was free..."
```

into:

> "They said it was free..."

Notice the beautiful punctuation. It does other nice things.

`smartypants` can be either a `boolean` (pass `false` to disable it), or an options object. Defaults to `true`. The possible options are as follows.

```sig
quotes: boolean = true;
```

Converts straight double and single quotes to smart double or single quotes.

- `"words"` **becomes**: "words"
- `'words` **becomes** 'words'

```sig
ellipses: boolean = true;
```

Converts triple dot characters (with or without spaces between) into a single unicode ellipsis character.

- `words...` **becomes** words...

```sig
backticks: boolean | 'all' = true;
```

When `true`, converts double back-ticks into an opening double quote, and double straight single quotes into a closing double quote.

- ` ``words'' ` **becomes** ``words''

When `'all'` it also converts single back-ticks into an opening single quote, and a straight single quote into a closing single smart quote.

Note: Quotes can not be true when backticks is 'all';

```sig
dashes: boolean | 'oldschool' | 'inverted' = true;
```

When `true`, converts two dashes into an em-dash character.

- `--` **becomes** —

When `'oldschool'`, converts two dashes into an en-dash, and three dashes into an em-dash.

- `--` **becomes** –
- `---` **becomes** —

When `'inverted'`, converts two dashes into an em-dash, and three dashes into an en-dash.

- `--` **becomes** —
- `---` **becomes** –

### `layout`

### `components`

### `remarkPlugins`

### `rehypePlugins`

## Frontmatter

### variables

### layout

### components

## Integrations

<!--
> ⚠️ MAKE SURE TO DOCUMENT THIS IN BOTH CLIENT AND SERVER PLUGIN CODE in rollup/webpack

Also, when you run `sapper dev` or `sapper export`, you have to run it with the `--ext` flag, like this:

```

"start": "sapper dev --ext '.svexy .svelte'",
"export": "sapper export --ext '.svexy .svelte'",

```

## Please, more.

### Executing Code

You can 'execute' javascript by defining a `js exec` fenced code block, these components and variables will then be available within the MDsveX file:

````mdsvex
```js exec
import Counter from './path/to/Counter.svelte';

let number = 500;
````

<Counter count="{number}" />

Inline components <Counter count="{5}" /> are absolute fine too.

`````

Use `js exec` blocks instead of script blocks because you can have as many `js exec` blocks as you want. And I can't remember if I tested script blocks.

You can also create [module scripts](https://svelte.dev/docs#script_context_module), if you so desire, by using `js module`:

````mdsvex
```js module
  export function someFunction(value) {
    // some stuff here
  }
```

<Counter />

````

### Styling

If you wish to style your markdown _inside_ an MDsveX file then you can do so with a `css style` fenced code block. Fenced style blocks ensure `style` elements are _always_ top level, which is required by Svelte, and prevents any problems with markdown interpreting your styles as text. You can use multiple fenced style blocks if you wish, they will be combined into a single style element:

````mdsvex
# Hello friends

```css style
  h1 {
    font-weight: 100;
  }
```
````

You can also use compile to js languages if you so desire, simply change `css` to the language of your choosing. Languages other than `css` applies a `lang="language"` attribute to the processed component allowing other Svelte preprocessors to transform those styles into plain CSS, as required by Svelte:

````mdsvex
# Hello friends

```scss style
  h1 {
    font-weight: 100;
  }
```
````

Will produce:

```svelte
<h1>Hello friends</h1>

<style lang="scss>
  h1 {
    font-weight: 100
  }
</style>
```

Magic!

### Front-Matter

You can add some YAML front-matter if you like. The variables and values defined in YAML front-matter are injected into the component's module script tag and are available in the MDsveX file. They are contained in an object named `_metadata`:

````mdsvex
---
number: 500
---

```js exec
import Counter from './path/to/Counter.svelte';

```

<Counter count="{_metadata.number}" />
````

This object is also exported from the module script tag, allowing you to import this metadata from the component for use elsewhere:

```js
import { _metadata } from "./article.svexy";
```

### Escaped Curlywurlies

Curlywurlies (`{` and `}`) are pretty special in Svelte components but this might be annoying when you're writing code snippets in fenced code blocks, so MDSveX escapes any curlywurlies non-executable in fenced code blocks:

The below is perfectly safe: the curlywurlies, which would normally cause issues, are escaped and should not bother you.

````mdsvex
```js
function myFunction(n) {
  return n * 2;
}
```

I am a sentence with an inline `{ code, snippet}` and i do not break either.
````

MDsveX does not escape curlywurlies outside of fenced code blocks nor does it escape curlywurlies in `js exec` blocks, so you can use dynamic values in component props and directly in markdown. This works:

````mdsvex
---
title: "The title for my great post"
---


```js exec
import Counter from './path/to/Counter.svelte';

let number = 500;
let text = { text: "Some random text." }
```

# { [1, 2, 3].reduce((a, n) => a + n, 0) }


> { [1, 2, 3].reduce((a, n) => a + n, 0) }



<Counter count="{number}" />

{ text.text }
````

### markdown-it plugins

You can add your own `markdown-it` plugins if you are feeling adventurous. You do it in your rollup or webpack config and you do it like this:

```js
plugins: [
    svelte({
      extensions: ['svelte', '.svexy', '.svx'], // here actually
      preprocess: mdsvex({
        parser: md => md.use(myMagicalPlugin)
        // this is the actual instance of markdown-it that will be used to parse things
        // mdsvex adds it's mofifications after yours
        // this could potentially break things
      }),
    }
  ]
```

### Custom layouts

You can add custom layouts to any individual MDsveX file or define a global default. You can optionally add a global Layout by adding an option to MDsveX. This needs to be an absolute path to a Svelte component with a `slot` element (so we can slot the actual MDsveX file in). Use `path.join(__dirname, './path/to/file.svelte')` or similar to avoid tragedy:

```js
import { mdsvex } from 'mdsvex';
import path from 'path';

export default {
  ...boringConfigStuff,
  plugins: [
    svelte({
      preprocess: mdsvex({
        layout: path.join(__dirname, './DefaultLayout.svelte'),
      }),
    }
  ]
}
```

You can also add a layout to an individual MDsveX file by declaring it in YAML front-matter under the `layout` property. When defined in front-matter, paths are relative to the location of that file:

```yaml
---
layout: ./path/to/file.svelte
---
# Your markdown goes here
```

Layouts defined in front-matter always take priority over global layouts, if they are defined. If there is no global layout then the local layout will still be used.

Layout components will receive all front-matter properties as props, so you can use things like titles, dates or cover images in your layout component and do snazzy stuff, without the headache of doing it manually. All front-matter values will be passed down, simply `export let` those values in your layout to make use of them. If you try to use a value in a layout that isn't defined in front-matter then Svelte will complain and your page will be plagued with `undefined` and broken-ness (unless you set defaults in the layout).

These are all just Svelte components at the end of the day, so refer to the Svelte [tutorial](https://svelte.dev/tutorial) and [documentation](https://svelte.dev/docs) if you are unsure how it all works. A Sapper/MDsveX template is also in the works (and by 'in the works' I mean that I haven't started it yet).
-->

[svelte]: https://svelte.dev/
[mdx]: https://mdxjs.com/
[unified]: https://unifiedjs.com/
[remark]: https://github.com/remarkjs
[rehype]: https://github.com/rehypejs/rehype
[remark_plugins]: https://github.com/remarkjs/remark/blob/master/doc/plugins.md#list-of-plugins
[rehype_plugins]: https://github.com/rehypejs/rehype/blob/master/doc/plugins.md#list-of-plugins
