---
layout: ./_DocsLayout.svelte
nav:
  - [Install, docs#install-it]
  - [Use, docs#use-it]
  - [
      Options,
      docs#options,
      [
        [extension, docs#extension, true],
        [smartypants, docs#smartypants, true],
        [layout, docs#layout, true],
        [components, docs#components, true],
        [remarkPlugins, docs#remarkplugins, true],
        [rehypePlugins, docs#rehypeplugins, true],
      ],
    ]
  - [
      Frontmatter,
      docs#frontmatter,
      [
        [variables, docs#variables, false],
        [layouts, docs#layout-1, false],
        [components, docs#components-1, false],
      ],
    ]
  - [Integrations, docs#integrations]
---

# mdsvex

A markdown preprocessor for [Svelte][svelte] components. Basically [MDX][mdx] for Svelte.

This preprocessor allows you to use Svelte components in your markdown, or markdown in your Svelte components.

mdsvex supports all Svelte syntax and _almost_ all markdown syntax. See [limitations](docs/#limitations) for more information.

You can do this:

```mdsvex
<script>
 import { Chart } from "../components/Chart.svelte";
</script>

# Here’s a chart

The chart is rendered inside our MDsveX document.

<Chart />
```

It uses [unified], [remark] and [rehype] and you can use any [remark plugins][remark_plugins] or [rehype plugins][rehype_plugins] to enhance your experience.

[Try it](/playground)

## Install it

Install it as a dev-dependency.

With `npm`:

```bash
npm i --save-dev mdsvex
```

With `yarn`:

```bash
yarn add --dev mdsvex
```

## Use it

The `mdsvex` preprocessor function is a named import from the `mdsvex` module. Add it as a preprocessor to you rollup or webpack config, and tell the Svelte plugin or loader to also handle `.svexy` files:

```js
import { mdsvex } from "mdsvex";

export default {
	...boring_config_stuff,
	plugins: [
		svelte({
			// tell svelte to handle mdsvex files
			extensions: [".svelte", ".svexy"],
			preprocess: mdsvex()
		})
	]
};
```

> If you don't like the `.svexy` file extension, fear not, it is easily customised.

## Options

The preprocessor function accepts an object of options, that allow you to customise your experience. The options are global to all parsed files.

```ts
interface MdsvexOptions {
	extension: string;
	smartypants: boolean | smartypantsOptions;
	layout: string | Array<string | RegExp, string>;
	components:
		| { [element: string]: string }
		| Array<string | RegExp, { [element: string]: string }>;
	remarkPlugins: Array<plugin> | Array<[plugin, plugin_options]>;
	rehypePlugins: Array<plugin> | Array<[plugin, plugin_options]>;
}
```

`mdsvex` also allows you to define individual options in [YAML frontmatter](docs#frontmatter), to modify behaviour on a _per-file_ basis.

### `extension`

```ts
extension: string = ".svexy";
```

The `extension` option allows you to set a custom file extension for files written in mdsvex; the default value is `.svexy`. Whatever value you choose here must be passed to the `extensions` field of `rollup-plugin-svelte` or `svelte-loader`. If you do not change the default, you must still pass the extension name to the plugin or loader config.

```js
export default {
	...config,
	plugins: [
		svelte({
			extensions: [".svelte", ".custom"],
			preprocess: mdsvex({
				extension: ".custom"
			})
		})
	]
};
```

### `smartypants`

```ts
smartypants: boolean | {
 quotes: boolean = true;
 ellipses: boolean = true;
 backticks: boolean | 'all' = true;
 dashes: boolean | 'oldschool' | 'inverted' = true;
} = true;
```

The `smartypants` options transforms ASCII punctuation into fancy typographic punctuation HTML entities.

It turns stuff like:

```md
"They said it was free..."
```

into:

> "They said it was free..."

Notice the beautiful punctuation. It does other nice things.

`smartypants` can be either a `boolean` (pass `false` to disable it) or an options object (defaults to `true`). The possible options are as follows.

```sig
quotes: boolean = true;
```

Converts straight double and single quotes to smart double or single quotes.

- `"words"` **becomes**: "words"
- `'words` **becomes** 'words'

```sig
ellipses: boolean = true;
```

Converts triple-dot characters (with or without spaces) into a single Unicode ellipsis character.

- `words...` **becomes** words...

```sig
backticks: boolean | 'all' = true;
```

When `true`, converts double back-ticks into an opening double quote, and double straight single quotes into a closing double quote.

- ` ``words'' ` **becomes** ``words''

When `'all'` it also converts single back-ticks into a single opening quote, and a single straight quote into a closing single, smart quote.

Note: Quotes can not be `true` when backticks is `'all'`;

```sig
dashes: boolean | 'oldschool' | 'inverted' = true;
```

When `true`, converts two dashes into an em-dash character.

- `--` **becomes** —

When `'oldschool'`, converts two dashes into an en-dash, and three dashes into an em-dash.

- `--` **becomes** –
- `---` **becomes** —

When `'inverted'`, converts two dashes into an em-dash, and three dashes into an en-dash.

- `--` **becomes** —
- `---` **becomes** –

### `layout`

```ts
layout: string | Array<string | RegExp, string>;
```

The `layout` option allows you to provide a custom layout component that will wrap your mdsvex file like so:

```svelte
<Layout>
 <MdsvexDocument />
<Layout>
```

> Layout components receive all frontmatter values as props, which should provide a great deal of flexibility when designing your layouts.

You can provide a `string`, which should be the path to your layout component. An absolute path is preferred but mdsvex tries to resolve relative paths based upon the current working directory.

```js
import { join } from "path";

const path_to_layout = join(__dirname, "./src/Layout.svelte");

mdsvex({
	layout: path_to_layout
});
```

In some cases you may want different layouts for different types of document, to address this you may pass an array instead of a string. Each item should also be an array containing only two elements (a tuple). The first element should either be a `string` or a `RegExp` object. The second should be a path pointing to your layout component, as described above.

The `string` or `RegExp` is used to test the path of the mdsvex document. The first passing test will be used, so depending on your requirements, the order may be important. This also allows you to pass a wildcard or default layout at the end.

As an example, you may have two folders containing mdsvex documents and want to use different layouts for each, you could do something like this:

```js
mdsvex({
	layouts: [
		["/blog/", "./path/to/blog/layout.svelte"],
		["/article/", "./path/to/article/layout.svelte"]
	]
});
```

In the above case, any mdsvex document containing `/blog/` would use `"./path/to/blog/layout.svelte"` as a layout, documents in `/article/` would use `"./path/to/article/layout.svelte"`. Anything that did not match however would not get a layout. You could provide a default or wildcard by either passing an empty string `""` or a Regular expresison that matches anything (like `[\s\S]*`):

```js
mdsvex({
	layouts: [
		["/blog/", "./path/to/blog/layout.svelte"],
		["/article/", "./path/to/article/layout.svelte"],
		["", "./path/to/default/layout.svelte"],
		// or
		[/[\s\S]*/, "./path/to/default/layout.svelte"]
	]
});
```

### `components`

```ts
components:
 | { [element: string]: string }
 | Array<string | RegExp, { [element: string]: string }>;
```

The `components` option allows you to provide components in place of the DOM elements your markdown converts to. For example:

```mdsvex
# hello
```

Would normally produce:

```svelte
<h1>hello</h1>
```

However, you can provide a custom component to use instead, producing:

```svelte
<CustomH1>hello</CustomH1>
```

Similar to layouts, you can set these custom components by passing an object that should map DOM elements to components. Just like layouts, it is safer if these are absolute paths to the replacement component, but mdsvex tries to resolve them based on the current working directory.

```js
mdsvex({
	components: {
		p: "./CustomP.svelte",
		h1: "./CustomH1.svelte"
	}
});
```

As with layouts, you may want different types of document to use different custom components. In these instances, you can provide an array. Each item should also be an array containing only two elements (a tuple). The first element should either be a `string` or a `RegExp` object. The second should be an object mapping elements to components, as above.

The `string` or `RegExp` is used to test the path of the mdsvex document. The first passing test is used: depending on your requirements, the order may be important. This also allows you to pass a 'wildcard' or 'default' layout at the end.

```js
mdsvex({
	components: [
		[
			"/blog/",
			{
				p: "./CustomP.svelte",
				h1: "./CustomH1.svelte"
			}
		],
		[
			"/article/",
			{
				p: "./CustomP-2.svelte",
				h1: "./CustomH1-2.svelte"
			}
		]
	]
});
```

In the above case, any mdsvex documents matching `/blog/` would use the provided components, documents matching `/article/` would use a different set. Anything that did not match however would use the default DOM elements. You could provide a default or wildcard 'match' by either passing an empty string `""` or a Regular expresison that matches anything (like `[\s\S]*`):

```js
mdsvex({
	components: [
		[
			"/blog/",
			{
				p: "./CustomP.svelte",
				h1: "./CustomH1.svelte"
			}
		],
		[
			"/article/",
			{
				p: "./CustomP-2.svelte",
				h1: "./CustomH1-2.svelte"
			}
		],
		[
			"",
			{
				p: "./DefaultP-2.svelte",
				h1: "./DefaultH1-2.svelte"
			}
		]
	]
});
```

### `remarkPlugins`

```ts
remarkPlugins: Array<plugin> | Array<[plugin, plugin_options]>;
```

mdsvex has a simple pipeline. Your source file is first parsed into a Markdown AST (MDAST), this is where remark plugins would run. Then it is converted into an HTML AST (HAST), this is where rehype plugins would be run. After this is it converted (stringified) into a valid Svelte component ready to be compiled.

[remark] has a vibrant plugin ecosystem and mdsvex allows you to pass any [remark plugins][remark_plugins] as options, which will run on the remark AST at the correct point in the pipeline.

This option takes an array. If you do not wish to pass any options to a plugin then you can simply pass an array of plugins like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	remarkPlugins: [containers, github]
});
```

If you _do_ wish to pass options to your plugins then those array items should be an array of `[plugin, options]`, like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	remarkPlugins: [
		[containers, container_opts],
		[github, github_opts]
	]
});
```

You can mix and match as needed, only providing an array when options are needed:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	remarkPlugins: [
		[containers, container_opts],
		github,
		another_plugin,
		[yet_another_plugin, more_options]
	]
});
```

Remark plugins work on the Markdown AST (MDAST) produced by remark and it is very easy to write your own custom plugins if the existing ones do not satisfy your needs!

### `rehypePlugins`

```ts
rehypePlugins: Array<plugin> | Array<[plugin, plugin_options]>;
```

mdsvex has a simple pipeline. Your source file is first parsed into a Markdown AST (MDAST) by [remark], this is where remark plugins would run. Then it is converted into an HTML AST (HAST) by [rehype], this is where rehype plugins would be run. After this is it converted (stringified) into a valid Svelte component ready to be compiled.

[rehype] has a vibrant plugin ecosystem and mdsvex allows you to pass any [rehype plugins][rehype_plugins] as options, which will run on the rehype AST at the correct point in the pipeline.

The `rehypePlugins` option is remarkably similar to the `remarkPlugins` option, except it is for rehype plugins rather than remark ones.

This option takes an array. If you do not wish to pass any options to a plugin then you can simply pass an array of plugins like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	rehypePlugins: [containers, github]
});
```

If you _do_ wish to pass options to your plugins then those array items should be an array of `[plugin, options]`, like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	rehypePlugins: [
		[containers, container_opts],
		[github, github_opts]
	]
});
```

You can mix and match as needed, only providing an array when options are needed:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	rehypePlugins: [
		[containers, container_opts],
		github,
		another_plugin,
		[yet_another_plugin, more_options]
	]
});
```

Remark plugins work on the HTML AST (HAST) produced by rehype and it is very easy to write your own custom plugins if the existing ones do not satisfy your needs!

## Frontmatter

YAML front-matter is a common convention in blog posts and mdsvex supports it out of the box. If you wnat to use a custom language in front-matter than you can pass a custom [`frontmatter`](docs#frontmatter) function to the mdsvex preprocessor.

### Variables

All variables defined in front-matter are available directly in the component, exactly as you wrote them:

```mdsvex
---
title: My lovely article
author: Dr. Fabuloso the Fabulous
---

# {title} by {author}

Some amazing content.
```

These same variable are also passed to the layout for that page (if you are using one) as props, allowing you to do some fun stuff. The above mdsvex file would compile to something that looks like:

```svelte
<Layout {title} {author}>
  <h1>{title} by {author}</h1>
  <p>Some amazing content.</p>
</Layout>
```

Inside the layout, you can expect these values and play around with them:

```svelte
<script>


  import Author from './Author.svelte';
  export let title;
  export let author;
</script>

<article>

  <h1>{title}</h1>

  <Author>
    The amazing: {author}
  </Author>

  <slot></slot>

</article>
```

Additionally, all of these variables are exported as a single object named `metadata` from the `context="module"` script, so they can easily be imported in javascript:

```svelte
<script context="module">
  export let metadata = {
    title: "My lovely article",
    author: "Dr. Fabuloso the Fabulous"
  };
</script>
```

Due to how `context="module"` scripts work, this metadata can be imported like this:

```js
import { metadata } from "./some-mdsvex-file.svexy";
```

### layout

### components

## Integrations

[svelte]: https://svelte.dev/
[mdx]: https://mdxjs.com/
[unified]: https://unifiedjs.com/
[remark]: https://github.com/remarkjs
[rehype]: https://github.com/rehypejs/rehype
[remark_plugins]: https://github.com/remarkjs/remark/blob/master/doc/plugins.md#list-of-plugins
[rehype_plugins]: https://github.com/rehypejs/rehype/blob/master/doc/plugins.md#list-of-plugins

```

```

```

```
