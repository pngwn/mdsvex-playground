---
layout: ./_DocsLayout.svelte
nav:
  - [Install, docs#install-it]
  - [Use, docs#use-it]
  - [
      Options,
      docs#options,
      [
        [extension, docs#extension, true],
        [smartypants, docs#smartypants, true],
        [layout, docs#layout, true],
        [remarkPlugins, docs#remarkplugins, true],
        [rehypePlugins, docs#rehypeplugins, true],
        [frontmatter, docs#frontmatter, true],
      ],
    ]
  - [
      Layouts,
      docs#layouts,
      [
        [named layouts, docs#named-layouts, false],
        [custom components, docs#custom-components, false],
      ],
    ]
  - [Frontmatter, docs#frontmatter-1]
  - [Integrations, docs#integrations]
---

# mdsvex

A markdown preprocessor for [Svelte][svelte] components. Basically [MDX][mdx] for Svelte.

This preprocessor allows you to use Svelte components in your markdown, or markdown in your Svelte components.

mdsvex supports all Svelte syntax and _almost_ all markdown syntax. See [limitations](docs/#limitations) for more information.

You can do this:

```mdsvex
<script>
 import { Chart } from "../components/Chart.svelte";
</script>

# Here’s a chart

The chart is rendered inside our MDsveX document.

<Chart />
```

It uses [unified], [remark] and [rehype] and you can use any [remark plugins][remark_plugins] or [rehype plugins][rehype_plugins] to enhance your experience.

[Try it](/playground)

## Install it

Install it as a dev-dependency.

With `npm`:

```bash
npm i --save-dev mdsvex
```

With `yarn`:

```bash
yarn add --dev mdsvex
```

## Use it

The `mdsvex` preprocessor function is a named import from the `mdsvex` module. Add it as a preprocessor to you rollup or webpack config, and tell the Svelte plugin or loader to also handle `.svexy` files:

```js
import { mdsvex } from "mdsvex";

export default {
	...boring_config_stuff,
	plugins: [
		svelte({
			// tell svelte to handle mdsvex files
			extensions: [".svelte", ".svexy"],
			preprocess: mdsvex()
		})
	]
};
```

> If you don't like the `.svexy` file extension, fear not, it is easily customised.

## Options

The preprocessor function accepts an object of options, that allow you to customise your experience. The options are global to all parsed files.

```ts
interface MdsvexOptions {
	extension: string;
	smartypants: boolean | smartypantsOptions;
	layout: string | { [name: string]: string };
	remarkPlugins: Array<plugin> | Array<[plugin, plugin_options]>;
	rehypePlugins: Array<plugin> | Array<[plugin, plugin_options]>;
	frontmatter: { parse: Function; marker: string };
}
```

`mdsvex` also allows you to define individual options in [YAML frontmatter](docs#frontmatter), to modify behaviour on a _per-file_ basis.

### `extension`

```ts
extension: string = ".svexy";
```

The `extension` option allows you to set a custom file extension for files written in mdsvex; the default value is `.svexy`. Whatever value you choose here must be passed to the `extensions` field of `rollup-plugin-svelte` or `svelte-loader`. If you do not change the default, you must still pass the extension name to the plugin or loader config.

```js
export default {
	...config,
	plugins: [
		svelte({
			extensions: [".svelte", ".custom"],
			preprocess: mdsvex({
				extension: ".custom"
			})
		})
	]
};
```

### `smartypants`

```ts
smartypants: boolean | {
 quotes: boolean = true;
 ellipses: boolean = true;
 backticks: boolean | 'all' = true;
 dashes: boolean | 'oldschool' | 'inverted' = true;
} = true;
```

The `smartypants` options transforms ASCII punctuation into fancy typographic punctuation HTML entities.

It turns stuff like:

```md
"They said it was free..."
```

into:

> "They said it was free..."

Notice the beautiful punctuation. It does other nice things.

`smartypants` can be either a `boolean` (pass `false` to disable it) or an options object (defaults to `true`). The possible options are as follows.

```sig
quotes: boolean = true;
```

Converts straight double and single quotes to smart double or single quotes.

- `"words"` **becomes**: "words"
- `'words` **becomes** 'words'

```sig
ellipses: boolean = true;
```

Converts triple-dot characters (with or without spaces) into a single Unicode ellipsis character.

- `words...` **becomes** words...

```sig
backticks: boolean | 'all' = true;
```

When `true`, converts double back-ticks into an opening double quote, and double straight single quotes into a closing double quote.

- ` ``words'' ` **becomes** ``words''

When `'all'` it also converts single back-ticks into a single opening quote, and a single straight quote into a closing single, smart quote.

Note: Quotes can not be `true` when backticks is `'all'`;

```sig
dashes: boolean | 'oldschool' | 'inverted' = true;
```

When `true`, converts two dashes into an em-dash character.

- `--` **becomes** —

When `'oldschool'`, converts two dashes into an en-dash, and three dashes into an em-dash.

- `--` **becomes** –
- `---` **becomes** —

When `'inverted'`, converts two dashes into an em-dash, and three dashes into an en-dash.

- `--` **becomes** —
- `---` **becomes** –

### `layout`

```ts
layout: string | Array<string | RegExp, string>;
```

The `layout` option allows you to provide a custom layout component that will wrap your mdsvex file like so:

```svelte
<Layout>
 <MdsvexDocument />
<Layout>
```

> Layout components receive all frontmatter values as props, which should provide a great deal of flexibility when designing your layouts.

You can provide a `string`, which should be the path to your layout component. An absolute path is preferred but mdsvex tries to resolve relative paths based upon the current working directory.

```js
import { join } from "path";

const path_to_layout = join(__dirname, "./src/Layout.svelte");

mdsvex({
	layout: path_to_layout
});
```

In some cases you may want different layouts for different types of document, to address this you may pass an object of named layouts instead. Each key should be a name for your layout, the value should be a path as described above. A fallback layout, or default, can be passed using `_` (underscore) as a key name.

```js
mdsvex({
	layouts: {
		blog: "./path/to/blog/layout.svelte",
		article: "./path/to/article/layout.svelte",
		_: "./path/to/fallback/layout.svelte"
	}
});
```

### `remarkPlugins`

```ts
remarkPlugins: Array<plugin> | Array<[plugin, plugin_options]>;
```

mdsvex has a simple pipeline. Your source file is first parsed into a Markdown AST (MDAST), this is where remark plugins would run. Then it is converted into an HTML AST (HAST), this is where rehype plugins would be run. After this is it converted (stringified) into a valid Svelte component ready to be compiled.

[remark] has a vibrant plugin ecosystem and mdsvex allows you to pass any [remark plugins][remark_plugins] as options, which will run on the remark AST at the correct point in the pipeline.

This option takes an array. If you do not wish to pass any options to a plugin then you can simply pass an array of plugins like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	remarkPlugins: [containers, github]
});
```

If you _do_ wish to pass options to your plugins then those array items should be an array of `[plugin, options]`, like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	remarkPlugins: [
		[containers, container_opts],
		[github, github_opts]
	]
});
```

You can mix and match as needed, only providing an array when options are needed:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	remarkPlugins: [
		[containers, container_opts],
		github,
		another_plugin,
		[yet_another_plugin, more_options]
	]
});
```

Remark plugins work on the Markdown AST (MDAST) produced by remark and it is very easy to write your own custom plugins if the existing ones do not satisfy your needs!

### `rehypePlugins`

```ts
rehypePlugins: Array<plugin> | Array<[plugin, plugin_options]>;
```

mdsvex has a simple pipeline. Your source file is first parsed into a Markdown AST (MDAST) by [remark], this is where remark plugins would run. Then it is converted into an HTML AST (HAST) by [rehype], this is where rehype plugins would be run. After this is it converted (stringified) into a valid Svelte component ready to be compiled.

[rehype] has a vibrant plugin ecosystem and mdsvex allows you to pass any [rehype plugins][rehype_plugins] as options, which will run on the rehype AST at the correct point in the pipeline.

The `rehypePlugins` option is remarkably similar to the `remarkPlugins` option, except it is for rehype plugins rather than remark ones.

This option takes an array. If you do not wish to pass any options to a plugin then you can simply pass an array of plugins like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	rehypePlugins: [containers, github]
});
```

If you _do_ wish to pass options to your plugins then those array items should be an array of `[plugin, options]`, like so:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	rehypePlugins: [
		[containers, container_opts],
		[github, github_opts]
	]
});
```

You can mix and match as needed, only providing an array when options are needed:

```js
import containers from "remark-containers";
import github from "remark-github";

mdsvex({
	rehypePlugins: [
		[containers, container_opts],
		github,
		another_plugin,
		[yet_another_plugin, more_options]
	]
});
```

Remark plugins work on the HTML AST (HAST) produced by rehype and it is very easy to write your own custom plugins if the existing ones do not satisfy your needs!

### `frontmatter`

```ts
frontmatter: { parse: Function, marker: string };
```

By default mdsvex supports yaml frontmatter, this is defined by enclosing the YAML in thre hyphens (`---`). If you want to use a custom language or marker for frontmatter then you can use the `frontmatter` option.

`frontmatter` should be an object that can be a passed a `marker` and a `parse` property.

```sig
marker: string = '-';
```

The marker option defines the fence for your frontmatter. This defaults to `-` which corresponds to the standard triple-hyphen syntax (`---`) that you would normally use to define frontmatter. You can pass in a custom string to change this behaviour:

```js
mdsvex({
	frontmatter: {
		marker: "+"
	}
});
```

Now you can use `+++` to mark frontmatter. Setting _only_ the marker will keep the default frontmatter parser which only supports YAML.

```sig
parse: (frontmatter, message) => Object | undefined
```

The `parse` property accepts a function which allows you to provide a custom parser for frontmatter. This is useful if you want to use a different language in your frontmatter.

The parse function gets the raw frontmatter as the first argument and a `messages` array as the second.

The function should return the parsed frontmatter (as an object of key-value pairs) if parsing is successful and return undefined or false if there is a problem. Any parsing errors or warnings should be pushed into the `messages` array which will be printed to the user at when mdsvex has finished parsing. If you would prefer to throw an error, you are free to do so but it will interupt the parsing process.

In the following example, we will modify the frontmatter handling so we can write our frontmatter in TOML with a triple-`+` fence.

```js
mdsvex({
	marker: "+",
	parse(frontmatter, messages) {
		try {
			return toml.parse(frontmatter);
		} catch (e) {
			messages.push(
				"Parsing error on line " +
					e.line +
					", column " +
					e.column +
					": " +
					e.message
			);
		}
	}
});
```

Now we will be able to write TOML frontmatter:

```mdsvex
+++
title = "TOML Example"

[owner]
name = "some name"
dob = 1879-05-27T07:32:00-08:00 # First class dates
+++
```

## Layouts

Layouts are one of the more powerful features available in mdsvex and allow for a great deal of flexibility. At their simplest a layout is just a component that wraps an mdsvex document. Providing a string as the layout option will enable this behaviour:

```js
mdsvex({
	layout: "./path/to/layout.svelte"
});
```

Layouts receive all values defined in frontmatter as props:

```svelte
<Layout {...props} >
  <!-- mdsvex content here -->
</Layout>
```

You can then use these values in your layout however you wish, a typical use might be to define some fancy formatting for headings, authors, and dates. Although you could do all kinds of wonderful things. You just need to make sure you provide a default `slot` so the mdsvex content can be passed into your layout and rendered.

```svelte
<script>
  export let title;
  export let author;
  export let date;
</script>

<h1>{ title }</h1>
<p class="date">on: { date }</p>
<p class="date">by: { author }</p>
<slot>
  <!-- the mdsvex content will be slotted in here -->
</slot>
```

### Named Layouts

In some cases you may want different layouts for different types of document. To address this you can pass an object of named layouts instead. Each key should be a name for your layout, the value should be the path to that layout file. A fallback layout, or default, can be passed using `_` (underscore) as a key name.

```js
mdsvex({
	layouts: {
		blog: "./path/to/blog/layout.svelte",
		article: "./path/to/article/layout.svelte",
		_: "./path/to/fallback/layout.svelte"
	}
});
```

If you pass an object of named layouts, you can decide which layout to use on a file-by-file basis by declaraing it the frontmatter. For example, if you wanted to force a document to be wrapped with the `blog` layout you would do the following:

```mdsvex
---
layout: blog
---
```

If you are using named layouts and do not have a layout field in the frontmatter then mdsvex will try to pick the correct one based on the folder a file is stored in. Take the following folder structure:

```
.
├── blog
│   └── my-blog-post.svexy
└── article
    └── my-article.svexy
```

If there is a layout named `blog` and `article` then documents in the `blog` folder will use the `blog` layout, articles in the `articles` folder will use the `article` layout. mdsvex will try to check both singular and pluralised names, as you may have named a folder `events` but the matching layout could be named `event`, however, having the same folder and layout name will make this process more reliable. The current working directory is removed from the path when checking for matches but nested folder can still cause problems if there are conflicts—shallow folder structures and unique folder and layout names will prevent these kinds of collisions.

If there is no matching layout then the fallback layout (`_`) will be applied, if there is no fallback then no layout will be applied.

### disabling a layout

If you are using layouts but wish to diable them for a specific component, then you can set the `layout` field to `false` to prevent the application of a layout.

```mdsvex
---
layout: false
---
```

### Custom Components

Layouts also allow you provide custom components to any mdsvex file they are applied to. Custom components replace the elements that markdown would normally generate.

```mdsvex
# Title

Some text

- a
- short
- list
```

Would normally compile to:

```svelte
<h1>Title</h1>
<p>Some text</p>
<ul>
  <li>a</li>
  <li>short</li>
  <li>list</li>
</ul>
```

Custom compments allow you to replace these element with components. You can define components by exporting an object names `component` from the `context="module"` script of your Layout file:

```svelte
<script context="module">
  import { H1, P, LI } from './components.js';
  export const components = { h1: H1, p: P, li: LI };
</script>
```

the `components` object must be an object of key-value pairs, the key must be the actual element you want to replace (`p`, `blockquote`, etc.), the value must be the component you wish to replace them with.

The above custom components would generate:

```svelte
<script>
  import { components as Components } from './Layout.svelte';
</script>

<Components.h1>Title</Components.h1>
<Components.p>Some text</Components.p>
<ul>
  <Components.li>a</Components.li>
  <Components.li>short</Components.li>
  <Components.li>list</Components.li>
</ul>
```

Notice that the `UL` is left intact: elements are replaced _after_ the markdown is parsed to HTML. This allows greater flexibility, for example, when using custom components to customise lists, tables or other markdown than compiles to a combination of different HTML elements.

## Frontmatter

YAML frontmatter is a common convention in blog posts and mdsvex supports it out of the box. If you want to use a custom language or marker for frontmatter than you can use the [`frontmatter`](docs#frontmatter) option to modify the default behaviour.

Mdsvex integrates well with frontmatter providing additional flexibility when authoring documents.

All variables defined in frontmatter are available directly in the component, exactly as you wrote them:

```mdsvex
---
title: My lovely article
author: Dr. Fabuloso the Fabulous
---

# {title} by {author}

Some amazing content.
```

Additionally, all of these variables are exported as a single object named `metadata` from the `context="module"` script, so they can easily be imported in javascript:

```svelte
<script context="module">
  export let metadata = {
    title: "My lovely article",
    author: "Dr. Fabuloso the Fabulous"
  };
</script>
```

Due to how `context="module"` scripts work, this metadata can be imported like this:

```js
import { metadata } from "./some-mdsvex-file.svexy";
```

Frontmatter also interacts with layouts, you can find more details in the [Layout section](docs#layouts).

## Integrations

[svelte]: https://svelte.dev/
[mdx]: https://mdxjs.com/
[unified]: https://unifiedjs.com/
[remark]: https://github.com/remarkjs
[rehype]: https://github.com/rehypejs/rehype
[remark_plugins]: https://github.com/remarkjs/remark/blob/master/doc/plugins.md#list-of-plugins
[rehype_plugins]: https://github.com/rehypejs/rehype/blob/master/doc/plugins.md#list-of-plugins
